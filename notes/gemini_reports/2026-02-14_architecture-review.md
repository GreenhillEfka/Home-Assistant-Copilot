# PilotSuite Architecture Review
**Datum:** 2026-02-14 22:09
**Modell:** Gemini 2.5 Pro
**Scope:** HA Integration (ai_home_copilot_hacs_repo) + Core Add-on (ha-copilot-repo)

---

## Executive Summary

Das PilotSuite Projekt verfügt über eine grundsätzlich solide Zwei-Komponenten-Architektur, die eine saubere Trennung von UI (HA-Integration) und Core-Logik (Add-on) anstrebt. Die Analyse zeigt jedoch signifikante Inkonsistenzen zwischen den beiden Repositories, insbesondere bei Versionierung und API-Nutzung. Die Kernarchitektur-Konzepte wie "Neuronen" und die "State→Neuron→Mood"-Kette sind in der Dokumentation zwar beschrieben, im Code aber nur rudimentär und prozedural statt in klaren Abstraktionen umgesetzt. Es gibt wachsende technische Schulden durch redundanten Code und offene TODOs. Die Sicherheit muss durch Härtung der Webhooks und striktere Eingabevalidierung verbessert werden.

---

## Konsistenz-Check

### 1. Versionen
- **Problem:** Die `manifest.json` der Integration und die Add-on-Version sind nicht synchronisiert
- **Risiko:** Ein Update der Integration bedeutet nicht zwangsläufig ein passendes Add-on, was zu Laufzeitfehlern führen kann
- **Empfehlung:** Kompatibilitäts-Mechanismus etablieren (z.B. API-Version-Header)

### 2. Config-Schemas
- **Problem:** Konfigurationsänderungen im Add-on (neue AI-Modelle, Parameter) werden nicht automatisch in der HA-Integration nachgeführt
- **Risiko:** Manuelle, fehleranfällige Synchronisation

### 3. API-Contracts
- **Problem:** Keine formale API-Spezifikation (OpenAPI/Swagger)
- **Risiko:** Fragile Kopplung zwischen Integration und Add-on
- **Beobachtung:** Endpunkte im Add-on entsprechen nicht immer den in der Integration erwarteten Schemas

---

## Architektur-Review

### 1. Trennung der Verantwortlichkeiten
| Aspekt | Bewertung |
|--------|-----------|
| Aufteilung Integration/Add-on | ✅ Exzellent |
| Konsequente Umsetzung | ⚠️ Teilweise |
| Logik in `coordinator.py` | ❌ Sollte ins Add-on |

**Problem:** In `coordinator.py` findet sich Logik zur Interpretation von Zuständen, die eigentlich in das Add-on gehört.

### 2. Neuronen-Modell
- **Konzept:** `unifi_neuron`, `energy_neuron` etc. als starke Abstraktionsidee
- **Problem:** Keine `Neuron`-Basisklasse im `ha-copilot-repo`
- **Folge:** Hartcodierte, prozedurale Implementierung statt einheitliches Interface
- **Auswirkung:** Erschwert Erweiterbarkeit und Wartung erheblich

### 3. State→Neuron→Mood Kette
- **Konzept:** Logisches Herzstück des Projekts
- **Problem:** Implementierung spiegelt Kette nicht explizit wider
- **Folge:** Verbindungen sind implizit und schwer zu debuggen
- **Empfehlung:** Klarem Datenflussmodell mit explizitem `MoodManager` folgen

---

## Technical Debt (priorisiert)

### Hohe Priorität
1. **Redundanter Code**
   - `copy_repository_files` implementiert Kopieren neu statt `shutil.copytree` zu nutzen
   - Wartungsintensiv, fehleranfällig

2. **Fehlende Abstraktionen**
   - Keine `Neuron`-Basisklasse
   - Code-Duplizierung zwischen Neuronen
   - Inkonsistentes Verhalten

### Mittlere Priorität
3. **TODOs und FIXMEs**
   - Zahlreiche Markierungen im Code
   - Unfertige Implementierungen, bekannte Bugs
   - Systematisch erfassen und abarbeiten

### Niedrige Priorität
4. **Veraltete Patterns**
   - `os.path` statt `pathlib`
   - Verboser Code

---

## Verbesserungs-Vorschläge

### Action Item 1: Build & Release Pipeline (High Priority)
**Was:** CI/CD-Pipeline mit GitHub Actions
- Tests bei jedem Push
- Versionssynchronisation Integration ↔ Add-on
- Release-Skript für gebündelte Artefakte

**Warum:** Code-Qualität sicherstellen, Abhängigkeiten managen

### Action Item 2: Architektur-Refactoring (Epic)
**Was:**
1. `BaseNeuron`-Abstraktionsklasse mit `process_state()`, `get_activation_level()`
2. Alle Neuronen migrieren
3. `MoodManager`-Modul für "State→Mood"-Logik

**Warum:** Konsistentes Design, reduzierte Duplizierung, expliziter Datenfluss, Testbarkeit

### Action Item 3: API-Contract definieren (Medium)
**Was:** OpenAPI-Spezifikation für Add-on-API
- Client-Code-Generierung für Integration möglich

**Warum:** Stabile, dokumentierte Schnittstelle, verhindert Breaking Changes

### Action Item 4: Sicherheits-Härtung (High)
**Was:**
1. Webhook-Authentifizierung (HA-Built-in oder IP-Validierung)
2. Strikte `vol.Schema`-Validierung in `config_flow.py`

**Warum:** Verhindert unautorisierte Aktionen, Injection-Risiken, fehlerhafte Konfigurationen

---

## Nächste Schritte

1. **Sofort:** API-Version-Header für Kompatibilitäts-Check
2. **Kurzfristig:** `BaseNeuron`-Klasse implementieren
3. **Mittelfristig:** OpenAPI-Spec und CI/CD-Pipeline
4. **Laufend:** TODO-Backlog pflegen und abarbeiten

---

*Generated by Gemini Architect Worker (cron: 38074fc7)*